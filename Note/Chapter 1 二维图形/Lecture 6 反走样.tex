\documentclass{ctexart}
\usepackage{Note}
\begin{document}
\section{反走样}
\subsection{反走样的理论基础}
\subsubsection{采样定理}
从连续的信号(例如渲染管线中的场景或矢量图)到离散的信号(例如显示器上的像素),我们需要对连续信号进行采样.最简单的采样方法是在目标像素的中心点对连续信号进行采样.然而,离散的信号有时并不能正确地反应连续信号.\\
\indent 根据Fourier变换的性质,可以得出:对连续函数$f_0(x)$以频率$f_s$进行采样,最终得到的离散函数$f_1(x)$的频谱$F_1(f)$是把原函数的频谱$F_0(f)$以$f_s$为周期进行周期延拓的结果.\\
\indent 记$f_0(x)$的截止频率为$f_0$(即其频域$F_0(f)$在$f>f_0$的区域上均为$0$),如果$f_s>2f_0$,那么将$F_0(f)$按照$f_s$为周期平移时就不会出现重叠,也就可以准确地复现$f_0(x)$.否则,当$F_1(f)$中出现重叠时,就出现了错误的频率信号,\tbf{走样(Aliasing)}就发生了.
\begin{theorem}[Nyquist-Shannon采样定理]
    对于一个截止频率为$f$的连续信号,如果以大于$2f$的采样频率对其进行采样,则可以准确重建该信号.否则,会发生混叠现象,无法准确重建信号.
\end{theorem}
因此,一切走样几乎都是因为采样频率$f_s$不足导致的.
\subsubsection{反走样的基本策略}
除了购买一块分辨率更高的屏幕之外,我们主要有两种反走样的策略:
\begin{enumerate}[label=\tbf{\arabic*}.,topsep=0pt,parsep=0pt,itemsep=0pt,partopsep=0pt]
    \item \tbf{预过滤(Pre-filtering)}:在采样前进行\tbf{低通滤波(Low-pass Filtering)},截断高于$f_s/2$的频率.
    \item \tbf{超采样(Supersampling)}:以高于$f_s$的频率进行采样,然后对采样结果进行低通滤波.
\end{enumerate}
\subsection{预过滤}
所谓低通滤波,在图像滤波中我们已经介绍过,主要是通过各种低通滤波器(主要是均值滤波器和高斯滤波器等)来实现的.然而,预过滤中的低通滤波是对连续信号进行的,在实现上稍有不同.
\subsubsection{不加权与加权面积采样}
我们主要介绍直线的采样.考虑直线$l:y=kx+b$,并将它视作一个具有一定宽度的矩形\footnote{似乎也有根据直线在像素内的长度进行着色的办法,但各处查找到的定义并不相同.此外,这种办法的边缘更加尖锐,效果不算太好.}.根据该矩形在某一像素内覆盖的面积为像素着色,即
\[\vec{c}_{\text{pixel}}=\dfrac{S_{\text{overlap}}}{S_{\text{pixel}}}\vec{c}_{\text{line}}\]
这种方法称为\tbf{不加权面积采样(Unweighted Area Sampling)}.更好的办法是按照像素到直线的距离对像素内的各点进行加权,即
\[\vec{c}_{\text{pixel}}=\dfrac{\iint_{\text{pixel}}w(d(x,y))\vec{c}_{\text{line}}\di S}{\iint_{\text{pixel}}w(d(x,y))\di S}\]
其中$d(x,y)$为像素内点$(x,y)$到直线的距离.这种方法称为\tbf{加权面积采样(Weighted Area Sampling)}.
\subsubsection{预滤波}
考虑原始图像$\mat{I}(x,y)$和输出图像$\mat{J}[x,y]$.最开始所述的点采样就是把$\mat{J}$中各像素的中心点在$\mat{I}$中对应的颜色直接赋值给整个像素:
\[\mat{J}[x,y]=\mat{I}\left(x+\dfrac12,y+\dfrac12\right)\]
如前所述,这会引入走样.\\
\indent 我们可以对$\mat{I}$作$1\times1$的低通滤波,即对$\mat{I}$中对应$1\times1$像素的区域进行平均:
\[\hat{\mat{I}}(x,y)=\iint_{[x-1/2,x+1/2]\times[y-1/2,y+1/2]}\mat{I}(x,y)\di S\]
然后对卷积后的图像$\hat{I}(x,y)$采样:
\[\mat{J}[x,y]=\hat{\mat{I}}\left(x+\dfrac12,y+\dfrac12\right)\]
这就相当于$\mat{J}$中每个像素是$\mat{I}$中对应$1\times1$区域的平均值,从而避免了走样.对于渲染中最常见的三角形,即
\[\mat{J}[x,y]=\dfrac{S_{\text{overlap}}}{S_{\text{pixel}}}\cdot\vec{c}\]
其中$\vec{c}$为三角形的颜色, $S_{\text{pixel}}$为像素面积, $S_{\text{overlap}}$为三角形与像素的重叠面积.
\subsubsection{纹理采样与MIP映射}
在渲染三维场景时,我们需要把二维图像(纹理)贴到三维物体上.当视点远离物体时(即对图像进行拉伸缩放等操作),如果我们直接对纹理进行采样,会出现明显的走样\footnote{极端一点,如果我们打算在一个像素内渲染人像,如果\textit{不小心}采样到头发上,就能看见一个黑色的头.这显然是不合适的.}.\\
\indent 解决这一问题的最简单办法是在渲染时进行预过滤.例如,考虑一张$1024\times1024$的纹理,在最终贴图中对应于一个$32\times32$的区域.我们可以对纹理做$32\times32$的均值滤波,然后对滤波后的图像进行采样.然而,在渲染复杂场景,贴图数量众多的情况下,这种方法的计算量过大,不太现实.\\
\indent 我们需要一种更高效合理的方法.考虑对上述纹理(记作$\text{Level}\ 0$)进行预先采样,每次进行$2\times2$的均值滤波,依次得到$512\times512$, $256\times256$等(分别记作$\text{Level}\ 1,2,\cdots$)尺寸图像.在实际渲染时,我们考虑目标区域的尺寸介于两张贴图的尺寸之间.对于每个待确定的像素$i$,通过一定的算法(这在三维渲染中应该会介绍)得出层次细节指数$\lambda_i$,选取要用到的两张贴图:
\[D_0=\left\lfloor \lambda_i\right\rfloor,\ \ D_1=\left\lceil \lambda_i\right\rceil\]
于是需要使用$\text{Level}\ D_0,D_1$两张贴图.接下来先确定像素$i$的采样点在$uv$坐标中的位置$\left(u_i,v_i\right)$,然后用该位置在两张贴图中对应的像素进行线性插值:
\[u_{i0}=\left\lfloor u_i\right\rfloor,\ \ u_{i1}=\left\lceil u_i\right\rceil,\ \ v_{i0}=\left\lfloor v_i\right\rfloor,\ \ v_{i1}=\left\lceil v_i,\ \ \delta_u=u_i-u_{i0},\ \ \delta_v=v_i-v_{i0}\right\rceil\]
\[\vec{c}_{i}=(1-\delta_u)(1-\delta_v)\mat{I}[u_{i0},v_{i0}]+\delta_u(1-\delta_v)\mat{I}[u_{i1},v_{i0}]+(1-\delta_u)\delta_v\mat{I}[u_{i0},v_{i1}]+\delta_u\delta_v\mat{I}[u_{i1},v_{i1}]\]
在$\text{Level}\ D_0,D_1$两张贴图中分别可以确定$\vec{c}_{i0},\vec{c}_{i1}$两个颜色.最终,在这两个颜色之间做线性插值可得最终像素$i$的颜色为
\[\vec{c}_i=(1-\lambda)\vec{c}_{i0}+\lambda\vec{c}_{i1}\]
这就是\tbf{多级渐远纹理映射(MIP Mapping)}的基本原理.不难得出,我们仅仅增加了$1/3$的空间开销,就能大大加快渲染过程并减少走样发生.
\subsection{超采样}
\subsubsection{超采样反走样(SSAA)}
超采样的基本思想是以高于显示器分辨率的频率对场景进行采样,然后对采样结果进行低通滤波.例如,对于一个$800\times600$的显示器,我们可以以$1600\times1200$的频率对场景进行采样,然后对采样结果进行$2\times2$的均值滤波,最后将滤波后的图像下采样到$800\times600$.这种方法称为\tbf{超采样反走样(Supersampling Anti-Aliasing, SSAA)}.
\begin{definition}[SSAA]
    \tbf{超采样反走样}是指以高于显示器分辨率的频率对场景进行采样,然后对采样结果进行低通滤波,最后将滤波后的图像缩小到显示器分辨率的过程.
\end{definition}
SSAA等价于在输出图像$\mat{J}$的每个像素对应于原始图像$\mat{I}$的区域内进行多次采样,然后取平均值.不难看出,在采样方式比较规则时,这等价于扩大分辨率后下采样至输出图像\footnote{但实际超采样时通常会避免将像素简单地划为规则排列的格子,而更常用低差异采样序列,即按一定随机形式排布的采样点.这能更有效地避免走样.}.\\
\indent SSAA的实现简单,效果也最好,但开销是最大的.在实际应用中很少如此使用.
\subsubsection{多重采样反走样(MSAA)}
SSAA的低效主要来源于对每个采样点颜色的单独计算,这意味着运行时间成倍的提升.\tbf{多重采样反走样(Multisample Anti-Aliasing, MSAA)}就是一种更高效的办法.\\
\indent 仍然考虑目标图像$\mat{J}$的一个像素$\mat{J}[x,y]$.和SSAA一样,我们先取定$\mat{J}[x,y]$中的$n$个采样点,不妨记作$S_1,\cdots,S_n$. MSAA的步骤如下:
\begin{enumerate}[label=\tbf{\arabic*}.,topsep=0pt,parsep=0pt,itemsep=0pt,partopsep=0pt]
    \item \tbf{几何测试}:对每个采样点$S_i$做三角形覆盖测试,确定其最终被哪个三角形覆盖.
    \item \tbf{着色计算}:对某一三角形,按照重心插值方法在$\mat{J}[x,y]$中心计算一次颜色,然后把该颜色赋值给所有被该三角形覆盖的采样点.
    \item 重复\tbf{2.},直到所有采样点$S_i$都被处理完毕.
    \item \tbf{合并颜色}:对像素$\mat{J}[x,y]$内的所有采样点的颜色取平均,作为$\mat{J}[x,y]$的颜色.
\end{enumerate}
\begin{definition}[MSAA]
    \tbf{多重采样反走样}是指对输出图像的每个像素取多个采样点,对每个采样点做几何测试,但只计算像素中心的颜色对采样点赋值,最后对采样点颜色取平均作为像素颜色的过程.
\end{definition}
无疑, MSAA相比SSAA大大减少了着色器的调用次数,尤其是在三角形的内部.此外,它还需要成倍的内存开销来存储采样点的信息.随着现代渲染场景的复杂化, MSAA也逐渐被更高效的反走样方法所取代.
\subsubsection{时域反走样(TAA)}
一般而言,渲染图像都是在时间上是连续的.因此,除了从空间上优化采样方式,还可以从时间上进行优化.\tbf{时域反走样(Temporal Anti-Aliasing, TAA)}就是一种利用时间信息进行反走样的方法.\\
\indent TAA的步骤如下:
\begin{enumerate}[label=\tbf{\arabic*}.,topsep=0pt,parsep=0pt,itemsep=0pt,partopsep=0pt]
    \item \tbf{抖动采样位置}:在MSAA中,我们是在一帧的一个像素内取多个位置不同的采样点.在TAA中,我们则是在连续的多帧的一个像素内取位置不同的采样点,这就需要对采样点的位置进行轻微移动.
    \item \tbf{着色计算}:正常执行渲染管线,计算当前帧当前采样点的颜色.
    \item \tbf{回溯采样点}:对于当前帧的采样点$S_{\text{current}}$,通过一定方法\footnote{这在后面的渲染的课程会介绍.}找到其在上一帧中对应区域的采样点$S_{\text{history}}$.
    \item \tbf{合并颜色}:对当前帧的采样点$S_{\text{current}}$和上一帧的采样点$S_{\text{history}}$的颜色进行加权平均:
        \[\vec{c}_{\text{result}}=(1-\alpha)\vec{c}_{\text{history}}+\alpha\vec{c}_{\text{current}}\]
        其中$\alpha$为权重系数,一般取$0.05$到$0.2$左右.将上述过程展开如下(下标$t$表示时间):
        \[\vec{c}_{t,\text{result}}=\alpha\vec{c}_{t}+(1-\alpha)\vec{c}_{t-1,\text{result}}=\alpha\sum_{k=0}^{\infty}(1-\alpha)^k\vec{c}_{k-t}\]
        可以看到当前帧的颜色是对历史帧加权平均的结果.
\end{enumerate}
在实际动态图像的渲染中, TAA的算法更为复杂(例如根据移动的程度决定混合权重系数等),但基本思路是一致的.
\begin{definition}[TAA]
    \tbf{时域反走样}是指在连续的多帧中对同一像素取位置不同的采样点,对当前帧的采样点进行着色计算,然后通过回溯找到上一帧对应区域的采样点,最后对当前帧和上一帧的采样点颜色进行加权平均作为当前帧像素颜色的过程.
\end{definition}
TAA的优点是开销较小(每一帧采样着色的次数明显小于SSAA和MSAA),但缺点也很明显,即会引入模糊和拖影现象.这在动态范围较大时更为明显.
\subsubsection{基于深度学习的反走样}
这里主要以NVIDIA的\tbf{深度学习超级采样(Deep Learning Super Sampling, DLSS)}为例进行介绍. DLSS的基本思路是利用深度学习的方法,通过对大量高质量图像的训练,让神经网络学习如何将低分辨率图像转换为高分辨率图像.\\
\indent 具体而言, NVIDIA通过大量数据(包括一个低分辨率的图像作为输入和对应的高分辨率图像作为输出)预训练模型,然后将参数写入显卡中.在实际渲染时,只需通过采样得到一个低分辨率图像,然后通过神经网络进行推理,即可输出对应的高分辨率图像,达到超采样的效果.\\
\indent DLSS技术和前面讲的几种反走样技术在实现原理上是不同的,它纯粹是力大砖飞的提高了分辨率.此外,模型还可以通过渲染帧的数据推理预测它们之间的画面,实现插帧的效果.在2K和4K分辨率下, DLSS对于帧率和画质的提升是飞跃级的, 几乎能达到四倍于原始帧率的程度.\\
\indent 当然, DLSS也有明显的缺点,例如需要一张NVIDIA的Geforce RTX 20系列以上的,具有Tensor Core的显卡.最新的DLSS 4.0只能在Geforce RTX 50系列显卡使用.此外,在高动态的场景下, DLSS仍会出现模糊和拖影现象.\\
\indent 另一种无需硬件支持的技术是AMD推出的\tbf{超分辨率锐画技术(FidelityFX Super Resolution, FSR)}. FSR的原理和DLSS类似,但不依赖Tensor Core等硬件,可以在大多数显卡上使用.然而, FSR的效果不如DLSS.\\
\indent 总而言之,基于深度学习的反走样技术是目前最先进的,它几乎战胜了以往所有的反走样技术,成为现代渲染中反走样和提高帧率的主流.
\end{document}