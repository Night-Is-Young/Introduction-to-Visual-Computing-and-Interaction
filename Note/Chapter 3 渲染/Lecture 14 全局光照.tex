\documentclass{ctexart}
\usepackage{Note}
\begin{document}
\section{全局光照}
\subsection{光线投射与光线追踪}
\subsubsection{光线投射}
大部分环境中的光都不能被镜头所捕捉,因此相比于考虑每个光源发出的每条光线,我们不妨采取逆向思维,考虑那些最终到达镜头的光线.由于光路是可逆的,因此我们从镜头向屏幕上的点连一条线,该射线在场景中击中的第一个物体将决定该点的颜色.
\begin{definition}[光线投射]
    光线投射(Ray Casting)是一种通过从观察点向场景中投射射线来确定可见表面和颜色的技术.
\end{definition}
因此,光线投射算法的基本流程如下:
\begin{enumerate}[label=\tbf{\arabic*.}]
    \item 对于屏幕的每个像素点$(x,y)$,从相机位置向场景中投射一条穿过$(x,y)$的射线$\vec{r}(t)=\vec{o}+t\vec{d}$.
    \item 计算射线$\vec{r}(t)$与场景中的物体第一次发生相交的位置$\vec{p}$.
    \item 将交点$\vec{p}$与所有光源相连,分别得到一根shadow ray.判断shadow ray在到达光源之前是否与其他物体相交,如果相交则该光源对点$\vec{p}$不可见,否则可见.
    \item 在可见的情况下,我们已经知道了指向光源的方向$\vec{l}$, 指向观察者的方向$-\vec{d}$,以及表面法线$\vec{n}$.使用在光照与着色中介绍的各种光照模型即可计算光源对点$\vec{p}$贡献的颜色.
    \item 将所有光源的贡献累加,得到最终的像素颜色.
\end{enumerate}
上述过程的伪代码可以表示如下:
\begin{lstlisting}[language=python]
for each pixel (x, y) do
    # Generate primary ray from camera through pixel
    ray = generateRay(camera, x, y)
    # Find intersection with scene.
    hitInfo = intersectScene(ray)
    if hitInfo.hit then
        color = vec3(0, 0, 0)
        # For each light source, check visibility and compute lighting.
        for each light in scene.lights do
            shadowRay = generateShadowRay(hitInfo.position, light.position)
            if not intersectScene(shadowRay).hit then
                color += computeLighting(hitInfo, light)
        setPixelColor(x, y, color)
    else
        setPixelColor(x, y, backgroundColor)
\end{lstlisting}
\subsubsection{光线追踪}
在实际情况下,物体接受的光照可能并不直接来自于光源,而可能经过其它物体的反射/折射再到达该物体上.为了考虑这些间接光照,我们需要引入光线追踪技术.
\begin{definition}[光线追踪]
    光线追踪(Ray Tracing)通过模拟光线在场景中的传播路径,包括反射和折射,来生成更加逼真的图像.
\end{definition}
光线追踪算法的基本流程如下:
\begin{enumerate}[label=\tbf{\arabic*.}]
    \item 对于屏幕的每个像素点$(x,y)$,从相机位置向场景中投射一条穿过$(x,y)$的射线$\vec{r}(t)=\vec{o}+t\vec{d}$.
    \item 计算射线$\vec{r}(t)$与场景中的物体第一次发生相交的位置$\vec{p}$.
    \item 按照光线投射中介绍的办法计算交点$\vec{p}$处直接来自于光源形成的颜色.
    \item 根据材质属性,生成反射射线和折射射线,递归地追踪这些射线以计算间接光照形成的颜色.
    \item 将局部光照和间接光照形成的颜色累加,得到最终的像素颜色.
\end{enumerate}
上述过程的递归形式的伪代码可以表示如下:
\begin{lstlisting}[language=python]
# Define recursively ray tracing function.
function traceRay(ray, depth):
    if depth > maxDepth then
        return backgroundColor
    hitInfo = intersectScene(ray)
    if hitInfo.hit then
        color = computeLocalLighting(hitInfo)
        # Compute reflection
        if hitInfo.material.reflective then
            reflectRay = generateReflectRay(hitInfo)
            color += hitInfo.material.reflectivity * traceRay(reflectRay, depth + 1)
        # Compute refraction
        if hitInfo.material.refractive then
            refractRay = generateRefractRay(hitInfo)
            color += hitInfo.material.transparency * traceRay(refractRay, depth + 1)
        return color
    else
        return backgroundColor
for each pixel (x, y) do
    ray = generateRay(camera, x, y)
    color = traceRay(ray, 0)
    setPixelColor(x, y, color)
\end{lstlisting}
光线追踪算法能够生成高度逼真的图像,但计算开销较大,因此在实际应用中通常会结合其他算法进行优化.我们将在之后讲到优化的方式.在此之前,我们先来了解光线投射/追踪的基本步骤,即光线求交.
\subsection{光线求交}
可以看出,在光线投射与光线追踪算法中,计算射线与场景中物体的交点是一个核心步骤.高效地实现光线求交对于提升渲染性能至关重要.下面我们将介绍几种常见的几何体与光线求交点的办法.在本节的推导中,我们假定光线的方程为
\[\vec{r}(t)=\vec{o}+t\vec{d},\quad 0\leq t<+\infty\]
其中$\vec{o}$意为Origin,即光线的起点,而$\vec{d}$意为Direction,即光线的方向向量.求得的$t$即与物体的交点到光线起点的距离.
\subsubsection{光线与球面求交}
考虑球心为$\vec{c}$,半径为$r$的球面,其隐式方程为
\[\left|\left|\vec{p}-\vec{c}\right|\right|^2=r^2\]
代入光线方程,我们有
\[\left|\left|\vec{o}+t\vec{d}-\vec{c}\right|\right|^2=r^2\]
展开后得到关于$t$的二次方程
\[t^2\vec{d}\cdot\vec{d}+2t\vec{d}\cdot(\vec{o}-\vec{c})+(\vec{o}-\vec{c})\cdot(\vec{o}-\vec{c})-r^2=0\]
设$a=\vec{d}\cdot\vec{d}$, $b=2\vec{d}\cdot(\vec{o}-\vec{c})$, $c=(\vec{o}-\vec{c})\cdot(\vec{o}-\vec{c})-r^2$, 则方程的解为
\[t=\frac{-b\pm\sqrt{b^2-4ac}}{2a}\]
根据判别式$b^2-4ac$的值,我们可以判断光线与球面的交点情况是相离,相切还是相交,然后根据求根公式即可求出交点.
\subsubsection{光线与长方体求交}
为了简化光线与物体的求交计算,我们通常对物体创建一个规则的几何外形将其包围.最常见的包围体是\tbf{轴对齐包围盒(Axis-Aligned Bounding Box, AABB)}.
\begin{definition}[轴对齐包围盒]
    轴对齐包围盒是指其边界与坐标轴平行的长方体,通常由最小点$\vec{p}_{\min}=(x_{\min},y_{\min},z_{\min})$和最大点$\vec{p}_{\max}=(x_{\max},y_{\max},z_{\max})$定义.
\end{definition}
这里介绍一种高效的光线与AABB求交的方法,即\tbf{Slabs Method}.不失一般性地,我们考虑长方体中平行于$xy$平面的表面.设表面所在的方程分别为$z=z_{\min}$和$z=z_{\max}$,则光线与这两个平面的交点$t$值分别为
\[t_{z_{\min}}=\frac{z_{\min}-\vec{o}_z}{\vec{d}_z},\quad t_{z_{\max}}=\frac{z_{\max}-\vec{o}_z}{\vec{d}_z}\]
于是光线处于这两个平面之间时总有
\[t_{z_{\min}}\leq t\leq t_{z_{\max}}\]
类似地,我们可以计算出光线与平行于$xy$平面和$yz$平面的交点$t$值,分别记为$t_{x_{\min}},t_{x_{\max}}$和$t_{y_{\min}},t_{y_{\max}}$.如果光线与长方体相交,那么它同时处于这三组平面之间,于是
\[\left[t_{x_{\min}},t_{x_{\max}}\right]\cap\left[t_{y_{\min}},t_{y_{\max}}\right]\cap\left[t_{z_{\min}},t_{z_{\max}}\right]\neq\varnothing\]
于是令
\[t_{\min}=\max\left\{t_{x_{\min}},t_{y_{\min}},t_{z_{\min}}\right\},\quad t_{\max}=\min\left\{t_{x_{\max}},t_{y_{\max}},t_{z_{\max}}\right\}\]
只需要$t_{\min}\leq t_{\max}$,则光线与长方体相交,交出的线段即为
\[\vec{r}'(t)=\vec{o}+t\vec{d},\quad t_{\min}\leq t\leq t_{\max}\]
\subsubsection{光线与三角面片求交}
三角面片是计算机图形学中最常用的基本几何体之一,因此高效地实现光线与三角面片的求交对于光线追踪算法至关重要.这里介绍一种常用的光线与三角面片求交算法,即\tbf{Möller-Trumbore算法}.对于三角形上任意一点$\vec{t}(u,v)$,其满足
\[\vec{t}(u,v)=(1-u-v)\vec{v}_0+u\vec{v}_1+v\vec{v}_2\]
这里的$u,v$即为点在三角形中的重心坐标,满足$u\geq0,v\geq0$且$u+v\leq1$.将上述方程与光线方程联立,可得
\[\vec{o}+t\vec{d}=(1-u-v)\vec{v}_0+u\vec{v}_1+v\vec{v}_2\]
整理后得到
\[-t\vec{d}+u(\vec{v}_1-\vec{v}_0)+v(\vec{v}_2-\vec{v}_0)=\vec{o}-\vec{v}_0\]
这一线性方程组的矩阵形式为
\[\begin{bmatrix}
    -\vec{d}&\vec{v}_1-\vec{v}_0&\vec{v}_2-\vec{v}_0
\end{bmatrix}\begin{bmatrix}
    t\\u\\v
\end{bmatrix}=\vec{o}-\vec{v}_0\]
令
\[\vec{D}=\vec{d},\quad\vec{E}_1=\vec{v}_1-\vec{v}_0,\quad\vec{E}_2=\vec{v}_2-\vec{v}_0,\quad\vec{T}=\vec{o}-\vec{v}_0\]
根据Cramer法则可知线性方程组的解为
\[\begin{bmatrix}
    t\\u\\v
\end{bmatrix}=\dfrac{1}{\det\begin{bmatrix}
    -\vec{D}&\vec{E}_1&\vec{E}_2
\end{bmatrix}}\begin{bmatrix}
    \det\begin{bmatrix}
        \vec{T}&\vec{E}_1&\vec{E}_2
    \end{bmatrix}\\[6pt]
    \det\begin{bmatrix}
        -\vec{D}&\vec{T}&\vec{E}_2
    \end{bmatrix}\\[6pt]
    \det\begin{bmatrix}
        -\vec{D}&\vec{E}_1&\vec{T}
    \end{bmatrix}
\end{bmatrix}\]
根据我们在线性代数中所学的知识有
\[\det\begin{bmatrix}
    \vec{A}&\vec{B}&\vec{C}
\end{bmatrix}=-(\vec{A}\times\vec{C})\cdot\vec{B}=-(\vec{C}\times\vec{B})\cdot\vec{A}\]
于是上式可以改写为
\[\begin{bmatrix}
    t\\u\\v
\end{bmatrix}=\dfrac{1}{(\vec{D}\times\vec{E}_2)\cdot\vec{E}_1}\begin{bmatrix}
    (\vec{T}\times\vec{E}_1)\cdot\vec{E}_2\\
    (\vec{D}\times\vec{E}_2)\cdot\vec{T}\\
    (\vec{T}\times\vec{E}_1)\cdot\vec{D}
\end{bmatrix}\]
令$\vec{P}=\vec{D}\times\vec{E}_2,\vec{Q}=\vec{T}\times\vec{E}_1$,则有
\[t=\dfrac{\vec{Q}\cdot\vec{E}_2}{\vec{P}\cdot\vec{E}_1},\quad u=\dfrac{\vec{P}\cdot\vec{T}}{\vec{P}\cdot\vec{E}_1},\quad v=\dfrac{\vec{Q}\cdot\vec{D}}{\vec{P}\cdot\vec{E}_1}\]
最后判断$u\geq0,v\geq0,u+v\leq1$且$t\geq0$即可确定光线与三角面片是否相交,如果相交则交点为$\vec{r}(t)=\vec{o}+t\vec{d}$,在三角面片上的重心坐标为$(u,v)$.\\
\indent 上述过程的算法流程如下:
\begin{enumerate}[label=\tbf{\arabic*.}]
    \item 按照定义计算辅助向量$\vec{D},\vec{E}_1,\vec{E}_2,\vec{T},\vec{P},\vec{Q}$.
    \item 判断行列式$\vec{P}\cdot\vec{E}_1$是否接近于0,如果是则光线与三角面片平行,不相交.
    \item 计算参数$t,u,v$的值.
    \item 判断$u\geq0,v\geq0,u+v\leq1$且$t\geq0$是否成立,如果成立则光线与三角面片相交,否则不相交.
\end{enumerate}
\subsection{空间加速结构}
如果每一次光线求交都要遍历场景中的所有三角面片,计算效率将非常低下.为了提升光线求交的效率,我们通常会使用空间加速结构对场景进行划分,从而减少每次求交时需要检查的三角面片数量.下面介绍几种常见的空间加速结构.从原理上而言,它们都是将空间划分为若干个区域,先判断光线是否与区域相交,如果相交才会进一步检查该区域内的物体,从而避免了很多不必要的求交计算.它们之间的区别主要在于区域划分的方式.
\subsubsection{层次包围盒}
\tbf{层次包围盒(Hierarchical Bounding Boxes)}是一种通过构建包围盒\footnote{一般而言,包围盒是一个包含其中所有物体的最小的长方体.光线与包围盒的求交可以用前面介绍的\tbf{Slabs}算法实现.}树来组织场景中物体的空间加速结构.包围盒树的每个节点表示一个包围盒,其子节点表示该包围盒内包含的更小的包围盒或物体.在光线求交时,首先检查光线与根节点的包围盒是否相交,如果相交则递归地检查子节点,否则跳过该子树.\\
\indent 容易看出建立查找树可以使得求交的时间复杂度从$O(n)$降低到$O(\log n)$,因此对于渲染效率有显著提升.我们现在来介绍层次包围盒构建的具体办法:
\begin{enumerate}[label=\tbf{\arabic*.}]
    \item 计算当前节点包含的所有物体的包围盒并存储.
    \item 按照一定的划分策略将物体划分为两个子集,作为该节点的子节点.
    \item 递归地对每个子节点重复上述过程,直到满足终止条件(如节点包含的物体数量小于某个阈值).
\end{enumerate}
\indent 在光线求交时,我们可以按照如下流程进行:
\begin{enumerate}[label=\tbf{\arabic*.}]
    \item 从根节点开始,检查光线与当前节点的包围盒是否相交.
    \item 如果相交,则递归地检查子节点;如果不相交,则跳过该子树.
    \item 当到达叶子节点时,对该节点包含的所有物体进行求交测试,记录光源到交点的距离.
    \item 递归结束后对最近的交点进行处理,计算颜色等信息,然后返回.
\end{enumerate}
需要注意的是,在递归的过程中并不需要对每个交点进行精确的计算(例如插值计算颜色等信息),这会严重影响效率,只需要更新最近的交点即可.
\subsubsection{八叉树}
我们在前面已经介绍过八叉树这一数据结构,它也可以用作空间加速.八叉树的每个节点表示一个立方体空间,其子节点表示该立方体被划分后的八个子立方体.在光线求交时,首先检查光线与根节点的立方体是否相交,如果相交则递归地检查子节点,否则跳过该子树.
\subsubsection{BSP树和KD树}
BSP树(Binary Space Partitioning Tree)和KD树(K-Dimensional Tree)是两种基于空间划分的加速结构.它们通过\textit{选择一个平面}\footnote{与BVH树不同的是BSP树和KD树并不需要重新计算每个子节点的包围盒,子节点的几何形状已经由划分平面天然地确定了.}将空间划分为两个子空间,并递归地对每个子空间进行划分,直到满足终止条件.在光线求交时,首先计算光线与当前节点的划分平面的交点,据此可以判断它与该平面划分出的两个子节点的相交关系,然后递归地检查相交的子节点.\\
\indent 两者的区别主要在于KD树的划分平面要求平行于$xy$, $yz$或$xz$平面(也即只能是$x=c$, $y=c$或$z=c$中的一种),而BSP树的划分平面可以是任意方向的平面.一般而言, KD树的构建和求交效率更高,而BSP树仅在一些特殊的场景下使用(例如场景中有很多倾斜的物体).
\end{document}